// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../core/spend_path.dart';
import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `try_from`

class APIAbsoluteTimelock {
  final APIAbsoluteTimelockType timelockType;
  final int value;

  const APIAbsoluteTimelock({required this.timelockType, required this.value});

  static Future<APIAbsoluteTimelock> fromConsensus({required int consensus}) =>
      RustLib.instance.api.crateApiModelApiAbsoluteTimelockFromConsensus(
        consensus: consensus,
      );

  Future<int> toConsensus() => RustLib.instance.api
      .crateApiModelApiAbsoluteTimelockToConsensus(that: this);

  @override
  int get hashCode => timelockType.hashCode ^ value.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIAbsoluteTimelock &&
          runtimeType == other.runtimeType &&
          timelockType == other.timelockType &&
          value == other.value;
}

enum APIAbsoluteTimelockType { blocks, timestamp }

enum APINetwork { bitcoin, testnet, testnet4, signet, regtest }

class APIPolicyPath {
  final String policyId;
  final Uint32List path;

  const APIPolicyPath({required this.policyId, required this.path});

  static Future<APIPolicyPath> default_() =>
      RustLib.instance.api.crateApiModelApiPolicyPathDefault();

  static Future<List<APIPolicyPath>> fromSpendpath({
    required SpendPath spendPath,
  }) => RustLib.instance.api.crateApiModelApiPolicyPathFromSpendpath(
    spendPath: spendPath,
  );

  @override
  int get hashCode => policyId.hashCode ^ path.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIPolicyPath &&
          runtimeType == other.runtimeType &&
          policyId == other.policyId &&
          path == other.path;
}

class APIPubKey {
  final String mfp;
  final String derivationPath;
  final String xpub;

  const APIPubKey({
    required this.mfp,
    required this.derivationPath,
    required this.xpub,
  });

  @override
  int get hashCode => mfp.hashCode ^ derivationPath.hashCode ^ xpub.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIPubKey &&
          runtimeType == other.runtimeType &&
          mfp == other.mfp &&
          derivationPath == other.derivationPath &&
          xpub == other.xpub;
}

class APIRelativeTimelock {
  final APIRelativeTimelockType timelockType;
  final int value;

  const APIRelativeTimelock({required this.timelockType, required this.value});

  static Future<APIRelativeTimelock> fromConsensus({required int consensus}) =>
      RustLib.instance.api.crateApiModelApiRelativeTimelockFromConsensus(
        consensus: consensus,
      );

  Future<int> toConsensus() => RustLib.instance.api
      .crateApiModelApiRelativeTimelockToConsensus(that: this);

  @override
  int get hashCode => timelockType.hashCode ^ value.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIRelativeTimelock &&
          runtimeType == other.runtimeType &&
          timelockType == other.timelockType &&
          value == other.value;
}

enum APIRelativeTimelockType { blocks, time }

class APISpendPath {
  final int id;
  final List<APIPolicyPath> policyPath;
  final int threshold;
  final List<String> mfps;
  final APIRelativeTimelock relTimelock;
  final APIAbsoluteTimelock absTimelock;
  final int wuBase;
  final int wuIn;
  final int wuOut;
  final int trDepth;
  final double vbSweep;

  const APISpendPath({
    required this.id,
    required this.policyPath,
    required this.threshold,
    required this.mfps,
    required this.relTimelock,
    required this.absTimelock,
    required this.wuBase,
    required this.wuIn,
    required this.wuOut,
    required this.trDepth,
    required this.vbSweep,
  });

  static Future<List<APISpendPath>> fromSorted({
    required List<SpendPath> coreSpendPaths,
  }) => RustLib.instance.api.crateApiModelApiSpendPathFromSorted(
    coreSpendPaths: coreSpendPaths,
  );

  @override
  int get hashCode =>
      id.hashCode ^
      policyPath.hashCode ^
      threshold.hashCode ^
      mfps.hashCode ^
      relTimelock.hashCode ^
      absTimelock.hashCode ^
      wuBase.hashCode ^
      wuIn.hashCode ^
      wuOut.hashCode ^
      trDepth.hashCode ^
      vbSweep.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APISpendPath &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          policyPath == other.policyPath &&
          threshold == other.threshold &&
          mfps == other.mfps &&
          relTimelock == other.relTimelock &&
          absTimelock == other.absTimelock &&
          wuBase == other.wuBase &&
          wuIn == other.wuIn &&
          wuOut == other.wuOut &&
          trDepth == other.trDepth &&
          vbSweep == other.vbSweep;
}

class APISpendPathDef {
  final int threshold;
  final List<String> mfps;
  final APIRelativeTimelock relTimelock;
  final APIAbsoluteTimelock absTimelock;
  final bool isKeyPath;

  const APISpendPathDef({
    required this.threshold,
    required this.mfps,
    required this.relTimelock,
    required this.absTimelock,
    required this.isKeyPath,
  });

  @override
  int get hashCode =>
      threshold.hashCode ^
      mfps.hashCode ^
      relTimelock.hashCode ^
      absTimelock.hashCode ^
      isKeyPath.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APISpendPathDef &&
          runtimeType == other.runtimeType &&
          threshold == other.threshold &&
          mfps == other.mfps &&
          relTimelock == other.relTimelock &&
          absTimelock == other.absTimelock &&
          isKeyPath == other.isKeyPath;
}

enum APIWalletType {
  p2Pkh,
  p2Wpkh,
  p2Sh,
  p2Wsh,
  p2Tr,
  p2ShWpkh,
  p2ShWsh,
  unknown,
}
