// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'model.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `network_display_name`

Future<APIAnalysisResult> analyzeDescriptor({required String descriptor}) =>
    RustLib.instance.api.crateApiAnalyzerAnalyzeDescriptor(
      descriptor: descriptor,
    );

Future<String> buildDescriptor({
  required APIWalletType walletType,
  required List<APIPubKey> keys,
  required List<APISpendPathDef> spendPaths,
}) => RustLib.instance.api.crateApiAnalyzerBuildDescriptor(
  walletType: walletType,
  keys: keys,
  spendPaths: spendPaths,
);

/// Calculate the deterministic rustId for a spend path
/// Delegates to core::spend_path::calculate_spend_path_id (single source of truth)
Future<int> calculateSpendPathId({
  required int threshold,
  required List<String> mfps,
  required int relTimelock,
  required int absTimelock,
}) => RustLib.instance.api.crateApiAnalyzerCalculateSpendPathId(
  threshold: threshold,
  mfps: mfps,
  relTimelock: relTimelock,
  absTimelock: absTimelock,
);

/// Validate a key and check network compatibility
///
/// Returns Ok(()) if the key is valid and compatible with the network,
/// or Err with a descriptive message if validation fails.
Future<void> validateKey({
  required String mfp,
  required String derivationPath,
  required String xpub,
  required APINetwork network,
}) => RustLib.instance.api.crateApiAnalyzerValidateKey(
  mfp: mfp,
  derivationPath: derivationPath,
  xpub: xpub,
  network: network,
);

class APIAnalysisResult {
  final String descriptor;
  final APINetwork network;
  final APIWalletType walletType;
  final List<APIPubKey> keys;
  final List<APISpendPath> spendPaths;

  const APIAnalysisResult({
    required this.descriptor,
    required this.network,
    required this.walletType,
    required this.keys,
    required this.spendPaths,
  });

  @override
  int get hashCode =>
      descriptor.hashCode ^
      network.hashCode ^
      walletType.hashCode ^
      keys.hashCode ^
      spendPaths.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIAnalysisResult &&
          runtimeType == other.runtimeType &&
          descriptor == other.descriptor &&
          network == other.network &&
          walletType == other.walletType &&
          keys == other.keys &&
          spendPaths == other.spendPaths;
}
